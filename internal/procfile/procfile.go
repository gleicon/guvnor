package procfile

import (
	"bufio"
	"fmt"
	"os"
	"path/filepath"
	"regexp"
	"strings"

	"github.com/gleicon/guvnor/internal/discovery"
	"github.com/gleicon/guvnor/internal/env"
)

// Process represents a single process definition from a Procfile
type Process struct {
	Name    string            `json:"name" yaml:"name"`
	Command string            `json:"command" yaml:"command"`
	Env     map[string]string `json:"env,omitempty" yaml:"env,omitempty"`
	Port    int               `json:"port,omitempty" yaml:"port,omitempty"`
}

// Procfile represents the entire Procfile configuration
type Procfile struct {
	Processes []Process         `json:"processes" yaml:"processes"`
	Env       map[string]string `json:"env,omitempty" yaml:"env,omitempty"`
	Metadata  map[string]string `json:"metadata,omitempty" yaml:"metadata,omitempty"`
	EnvConfig *env.EnvConfig    `json:"-" yaml:"-"` // Loaded from .env files
}

var (
	// Procfile line pattern: process_name: command
	proclineRegex = regexp.MustCompile(`^([a-zA-Z0-9_-]+):\s*(.+)$`)
	// Comment patterns
	commentRegex = regexp.MustCompile(`^\s*(#|//).*$`)
	// Empty line pattern
	emptyLineRegex = regexp.MustCompile(`^\s*$`)
)

// ParseProcfile parses a Procfile from the given path with 12-factor .env support
func ParseProcfile(path string) (*Procfile, error) {
	file, err := os.Open(path)
	if err != nil {
		return nil, fmt.Errorf("failed to open Procfile: %w", err)
	}
	defer file.Close()

	pf := &Procfile{
		Processes: []Process{},
		Env:       make(map[string]string),
		Metadata:  make(map[string]string),
	}

	// Load .env files from the same directory as Procfile (12-factor compliance)
	procfileDir := filepath.Dir(path)
	if envConfig, err := env.LoadDotEnv(procfileDir); err == nil {
		pf.EnvConfig = envConfig
	}

	scanner := bufio.NewScanner(file)
	lineNum := 0

	for scanner.Scan() {
		lineNum++
		line := strings.TrimSpace(scanner.Text())

		// Skip empty lines and comments
		if emptyLineRegex.MatchString(line) || commentRegex.MatchString(line) {
			continue
		}

		// Parse process line
		matches := proclineRegex.FindStringSubmatch(line)
		if matches == nil {
			return nil, fmt.Errorf("invalid Procfile format at line %d: %s", lineNum, line)
		}

		processName := matches[1]
		command := strings.TrimSpace(matches[2])

		// Check for duplicate process names
		for _, existing := range pf.Processes {
			if existing.Name == processName {
				return nil, fmt.Errorf("duplicate process name '%s' at line %d", processName, lineNum)
			}
		}

		process := Process{
			Name:    processName,
			Command: command,
			Env:     make(map[string]string),
		}

		// Set smart defaults based on process name
		setSmartDefaults(&process)

		pf.Processes = append(pf.Processes, process)
	}

	if err := scanner.Err(); err != nil {
		return nil, fmt.Errorf("error reading Procfile: %w", err)
	}

	if len(pf.Processes) == 0 {
		return nil, fmt.Errorf("no valid processes found in Procfile")
	}

	// Assign smart ports
	assignSmartPorts(pf.Processes)

	return pf, nil
}

// WriteProcfile writes a Procfile to the specified path
func WriteProcfile(pf *Procfile, path string) error {
	file, err := os.Create(path)
	if err != nil {
		return fmt.Errorf("failed to create Procfile: %w", err)
	}
	defer file.Close()

	// Write header comment
	if _, err := fmt.Fprintf(file, "# Procfile - Process Configuration\n"); err != nil {
		return fmt.Errorf("failed to write header: %w", err)
	}

	if _, err := fmt.Fprintf(file, "# Generated by guvnor\n\n"); err != nil {
		return fmt.Errorf("failed to write header: %w", err)
	}

	// Write processes
	for _, process := range pf.Processes {
		if _, err := fmt.Fprintf(file, "%s: %s\n", process.Name, process.Command); err != nil {
			return fmt.Errorf("failed to write process %s: %w", process.Name, err)
		}
	}

	return nil
}

// FindProcfile searches for a Procfile in the given directory
func FindProcfile(dir string) (string, error) {
	candidates := []string{
		"Procfile",
		"Procfile.dev",
		"Procfile.development",
		"Procfile.local",
		"procfile",
		"PROCFILE",
	}

	for _, candidate := range candidates {
		path := filepath.Join(dir, candidate)
		if _, err := os.Stat(path); err == nil {
			return path, nil
		}
	}

	return "", fmt.Errorf("no Procfile found in directory: %s", dir)
}

// CreateEmptyProcfile creates an empty Procfile template
func CreateEmptyProcfile(path string) error {
	content := `# Procfile - Process Configuration
# Define your application processes here
# Format: <process_name>: <command>
#
# Examples:
# web: python app.py
# worker: python worker.py
# clock: python scheduler.py
#
# Environment variables like $PORT are automatically substituted

# web: echo "Replace this with your web server command"
`

	return os.WriteFile(path, []byte(content), 0644)
}

// CreateSmartProcfile creates a Procfile from discovered applications
func CreateSmartProcfile(path string, apps []*discovery.App) error {
	pf := &Procfile{
		Processes: []Process{},
		Env:       make(map[string]string),
		Metadata:  make(map[string]string),
	}

	// Convert discovered apps to Procfile processes
	for _, app := range apps {
		// Build command from app definition
		command := app.Command
		if len(app.Args) > 0 {
			command = command + " " + strings.Join(app.Args, " ")
		}

		// Map app name to appropriate process type
		processType := mapAppToProcessType(app)

		process := Process{
			Name:    processType,
			Command: command,
			Port:    app.Port,
			Env:     make(map[string]string),
		}

		// Copy environment variables, replacing port placeholders
		for k, v := range app.Env {
			if k == "PORT" || strings.Contains(v, "$PORT") {
				process.Env[k] = "$PORT"
			} else {
				process.Env[k] = v
			}
		}

		pf.Processes = append(pf.Processes, process)
	}

	pf.Metadata["generated"] = "guvnor"
	pf.Metadata["source"] = "smart-discovery"

	return WriteProcfile(pf, path)
}


// ConvertToDiscoveryApps converts Procfile processes to discovery.App format
func (pf *Procfile) ConvertToDiscoveryApps(basePath string) ([]*discovery.App, error) {
	var apps []*discovery.App

	for _, process := range pf.Processes {
		// Parse command into command and args
		cmdParts := strings.Fields(process.Command)
		if len(cmdParts) == 0 {
			continue
		}

		command := cmdParts[0]
		args := cmdParts[1:]

		// Create discovery app
		app := &discovery.App{
			Name:        process.Name,
			Type:        detectTypeFromProcess(&process),
			Path:        basePath,
			Port:        process.Port,
			Command:     command,
			Args:        args,
			Env:         make(map[string]string),
			HealthCheck: getHealthCheckForProcessType(process.Name),
		}

		// Copy environment variables
		for k, v := range process.Env {
			app.Env[k] = v
		}

		// Merge global environment
		for k, v := range pf.Env {
			if _, exists := app.Env[k]; !exists {
				app.Env[k] = v
			}
		}

		apps = append(apps, app)
	}

	// Assign ports to apps that need them
	usedPorts := make(map[int]bool)
	basePort := 5000

	for _, app := range apps {
		if app.Port == 0 && needsPortForApp(app.Name) {
			port := basePort
			for usedPorts[port] {
				port++
			}
			app.Port = port
			usedPorts[port] = true
		} else if app.Port != 0 {
			usedPorts[app.Port] = true
		}
	}

	return apps, nil
}

// Helper functions

func setSmartDefaults(process *Process) {
	switch process.Name {
	case "web":
		if process.Port == 0 {
			process.Port = 5000 // Heroku default
		}
		process.Env["PORT"] = "$PORT"

	case "worker", "job", "jobs":
		// Workers typically don't need ports

	case "clock", "scheduler", "cron":
		// Schedulers typically don't need ports

	case "redis", "cache":
		if process.Port == 0 {
			process.Port = 6379
		}

	case "postgres", "db", "database":
		if process.Port == 0 {
			process.Port = 5432
		}

	case "mongo", "mongodb":
		if process.Port == 0 {
			process.Port = 27017
		}
	}
}

func assignSmartPorts(processes []Process) {
	usedPorts := make(map[int]bool)
	basePort := 5000

	for i := range processes {
		if processes[i].Port == 0 && needsPort(processes[i].Name) {
			port := basePort
			for usedPorts[port] {
				port++
			}
			processes[i].Port = port
			usedPorts[port] = true
		} else if processes[i].Port != 0 {
			usedPorts[processes[i].Port] = true
		}
	}
}

func needsPort(processName string) bool {
	switch processName {
	case "web", "api", "server", "app", "frontend", "backend":
		return true
	case "worker", "job", "jobs", "clock", "scheduler", "cron":
		return false
	default:
		return true // Default to needing a port
	}
}

func mapAppToProcessType(app *discovery.App) string {
	switch app.Type {
	case "python", "nodejs", "go", "rust":
		// Check if it's likely a web server
		if strings.Contains(app.Command, "server") ||
			strings.Contains(app.Command, "uvicorn") ||
			strings.Contains(app.Command, "gunicorn") ||
			strings.Contains(app.Command, "flask") ||
			app.Port > 0 {
			return "web"
		}
		return "worker"
	default:
		return "web"
	}
}

func detectTypeFromProcess(process *Process) string {
	cmd := strings.ToLower(process.Command)

	if strings.Contains(cmd, "python") {
		return "python"
	}
	if strings.Contains(cmd, "node") || strings.Contains(cmd, "npm") {
		return "nodejs"
	}
	if strings.Contains(cmd, "go run") {
		return "go"
	}
	if strings.Contains(cmd, "cargo run") {
		return "rust"
	}

	return "generic"
}

func getHealthCheckForProcessType(processType string) string {
	switch processType {
	case "web", "api", "server":
		return "/health"
	default:
		return ""
	}
}

func needsPortForApp(appName string) bool {
	switch appName {
	case "web", "api", "server", "app", "frontend", "backend":
		return true
	case "worker", "job", "jobs", "clock", "scheduler", "cron":
		return false
	default:
		return true // Default to needing a port
	}
}

// GetProcessEnvironment returns the complete environment for a process (12-factor compliant)
func (pf *Procfile) GetProcessEnvironment(process *Process) []string {
	if pf.EnvConfig == nil {
		return os.Environ()
	}

	return pf.EnvConfig.GetEnvForProcess(process.Env)
}

// SubstituteCommand performs environment variable substitution in process commands
func (pf *Procfile) SubstituteCommand(process *Process) string {
	command := process.Command

	if pf.EnvConfig != nil {
		command = pf.EnvConfig.SubstituteVariables(command)
	}

	// Substitute PORT specifically
	if process.Port > 0 {
		command = strings.ReplaceAll(command, "$PORT", fmt.Sprintf("%d", process.Port))
		command = strings.ReplaceAll(command, "${PORT}", fmt.Sprintf("%d", process.Port))
	}

	return command
}

// ValidateEnvironment checks for common 12-factor compliance issues
func (pf *Procfile) ValidateEnvironment() []string {
	var warnings []string

	if pf.EnvConfig != nil {
		warnings = append(warnings, pf.EnvConfig.Validate()...)
	}

	// Check for hardcoded values in process commands
	for _, process := range pf.Processes {
		if strings.Contains(process.Command, "localhost") {
			warnings = append(warnings, fmt.Sprintf("Process '%s' contains hardcoded localhost", process.Name))
		}

		if strings.Contains(process.Command, "127.0.0.1") {
			warnings = append(warnings, fmt.Sprintf("Process '%s' contains hardcoded IP address", process.Name))
		}
	}

	return warnings
}

